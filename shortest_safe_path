#Busco la cantidad mínima de saltos a realizar para llegar desde la piedra 0 a la piedra len(c)-1. Para ello, calculo todos los caminos *factibles*, elijo al de menor distancia y retorno su distancia menos 1. 

def jumpOnMarsh(c):
#creo una lista vacía llamada _paths_ donde guardo todos los caminos factibles
  paths = []
#hago el primer paso, “salto” a la piedra 0
  jump([0], c, paths, len(c) - 1)
#cuando termina de ejecutarse _jump_ se tienen todos los caminos factibles en la variable _paths_. Solo resta buscar el más corto y retornar su longitud menos 1
  paths.sort(key=lambda path: len(path))
  return len(paths[0]) - 1


def jump(currentPath, c, paths, finalStone):
    lastStoneVisited = currentPath[len(currentPath) - 1]
#Analizo si la última piedra del recorrido parcial es la última. 
#Si lo es, agrego el camino a _paths_ 
    if (lastStoneVisited == finalStone):
      paths.append(currentPath)
#Si no lo es, analizo los saltos seguros a hacer y por cada uno de ellos llamo a la función _jump_ con los nuevos saltos. Cada llamado a _jump_ va a repetir este paso, por ende al llegar al final del camino la función termina su ejecución.
    else:
      if (lastStoneVisited + 1 <= finalStone and c[lastStoneVisited + 1] == 0):
        jump(currentPath + [lastStoneVisited + 1], c, paths, finalStone)
      if (lastStoneVisited + 2 <= finalStone and c[lastStoneVisited + 2] == 0):
        jump(currentPath + [lastStoneVisited + 2], c, paths, finalStone)

if (jumpOnMarsh([0,1,0,0,0,1,0]) == 3):
  print("It works")
else:
  print("Error")
